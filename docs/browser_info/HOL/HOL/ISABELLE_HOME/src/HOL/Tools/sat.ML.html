<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‹Tools/sat.ML›</title>
</head>


<body>
<div class="head">
<h1>File ‹Tools/sat.ML›</h1>
</div>

<pre class="source"><span class="comment1"><span>(*  Title:      HOL/Tools/sat.ML
    Author:     Stephan Merz and Alwen Tiu, QSL Team, LORIA (http://qsl.loria.fr)
    Author:     Tjark Weber, TU Muenchen

Proof reconstruction from SAT solvers.

  Description:
    This file defines several tactics to invoke a proof-producing
    SAT solver on a propositional goal in clausal form.

    We use a sequent presentation of clauses to speed up resolution
    proof reconstruction.
    We call such clauses "raw clauses", which are of the form
          [x1, ..., xn, P] |- False
    (note the use of |- instead of ==&gt;, i.e. of Isabelle's (meta-)hyps here),
    where each xi is a literal (see also comments in cnf.ML).

    This does not work for goals containing schematic variables!

      The tactic produces a clause representation of the given goal
      in DIMACS format and invokes a SAT solver, which should return
      a proof consisting of a sequence of resolution steps, indicating
      the two input clauses, and resulting in new clauses, leading to
      the empty clause (i.e. "False").  The tactic replays this proof
      in Isabelle and thus solves the overall goal.

  There are three SAT tactics available.  They differ in the CNF transformation
  used. "sat_tac" uses naive CNF transformation to transform the theorem to be
  proved before giving it to the SAT solver.  The naive transformation in the
  worst case can lead to an exponential blow up in formula size.  Another
  tactic, "satx_tac", uses "definitional CNF transformation" which attempts to
  produce a formula of linear size increase compared to the input formula, at
  the cost of possibly introducing new variables.  See cnf.ML for more
  comments on the CNF transformation.  "rawsat_tac" should be used with
  caution: no CNF transformation is performed, and the tactic's behavior is
  undefined if the subgoal is not already given as [| C1; ...; Cn |] ==&gt; False,
  where each Ci is a disjunction.

  The SAT solver to be used can be set via the "solver" reference.  See
  sat_solvers.ML for possible values, and etc/settings for required (solver-
  dependent) configuration settings.  To replay SAT proofs in Isabelle, you
  must of course use a proof-producing SAT solver in the first place.

  Proofs are replayed only if "quick_and_dirty" is false.  If
  "quick_and_dirty" is true, the theorem (in case the SAT solver claims its
  negation to be unsatisfiable) is proved via an oracle.
*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>signature</span></span></span><span> </span><span class="entity"><span>SAT</span></span><span> </span><span class="main"><span>=</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>sig</span></span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> trace</span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span>Config.T</span><span>  </span><span class="comment1"><span>(* print trace messages *)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> solver</span><span class="main"><span>:</span></span><span> </span><span>string</span><span> </span><span>Config.T</span><span>  </span><span class="comment1"><span>(* name of SAT solver to be used *)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> counter</span><span class="main"><span>:</span></span><span> </span><span>int</span><span> </span><span>Unsynchronized.ref</span><span>     </span><span class="comment1"><span>(* output: number of resolution steps during last proof replay *)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> rawsat_thm</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>cterm</span><span> </span><span>list</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> rawsat_tac</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> sat_tac</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> satx_tac</span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>SAT</span></span><span> </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>SAT</span></span><span> </span><span class="main"><span>=</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>struct</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>trace</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Attrib.setup_config_bool</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span></span><span>‹</span><span class="entity_def" id="SAT.sat_trace|attribute"><span>sat_trace</span></span><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span>false</span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>msg</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Config.get</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>trace</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>tracing</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>msg</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>solver</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Attrib.setup_config_string</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">binding</span><span class="hidden">&gt;</span></span></span><span>‹</span><span class="entity_def" id="SAT.sat_solver|attribute"><span>sat_solver</span></span><span>›</span></span></span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span class="inner_quoted"><span>"cdclite"</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
  </span><span class="comment1"><span>(*see HOL/Tools/sat_solver.ML for possible values*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>counter</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Unsynchronized.ref</span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* lit_ord: an order on integers that considers their absolute values only,  *)</span></span><span>
</span><span class="comment1"><span>(*      thereby treating integers that represent the same atom (positively   *)</span></span><span>
</span><span class="comment1"><span>(*      or negatively) as equal                                              *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>lit_ord</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>j</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>int_ord</span><span> </span><span class="main"><span>(</span></span><span>abs</span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>,</span></span><span> </span><span>abs</span><span> </span><span class="entity"><span>j</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* CLAUSE: during proof reconstruction, three kinds of clauses are           *)</span></span><span>
</span><span class="comment1"><span>(*      distinguished:                                                       *)</span></span><span>
</span><span class="comment1"><span>(*      1. NO_CLAUSE: clause not proved (yet)                                *)</span></span><span>
</span><span class="comment1"><span>(*      2. ORIG_CLAUSE: a clause as it occurs in the original problem        *)</span></span><span>
</span><span class="comment1"><span>(*      3. RAW_CLAUSE: a raw clause, with additional precomputed information *)</span></span><span>
</span><span class="comment1"><span>(*         (a mapping from int's to its literals) for faster proof           *)</span></span><span>
</span><span class="comment1"><span>(*         reconstruction                                                    *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>datatype</span></span></span><span> </span><span class="entity"><span>CLAUSE</span></span><span> </span><span class="main"><span>=</span></span><span>
    </span><span class="entity"><span>NO_CLAUSE</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>ORIG_CLAUSE</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> thm
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>RAW_CLAUSE</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> thm * </span><span class="main"><span>(</span></span><span>int * cterm</span><span class="main"><span>)</span></span><span> list</span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* resolve_raw_clauses: given a non-empty list of raw clauses, we fold       *)</span></span><span>
</span><span class="comment1"><span>(*      resolution over the list (starting with its head), i.e. with two raw *)</span></span><span>
</span><span class="comment1"><span>(*      clauses                                                              *)</span></span><span>
</span><span class="comment1"><span>(*        [P, x1, ..., a, ..., xn] |- False                                  *)</span></span><span>
</span><span class="comment1"><span>(*      and                                                                  *)</span></span><span>
</span><span class="comment1"><span>(*        [Q, y1, ..., a', ..., ym] |- False                                 *)</span></span><span>
</span><span class="comment1"><span>(*      (where a and a' are dual to each other), we convert the first clause *)</span></span><span>
</span><span class="comment1"><span>(*      to                                                                   *)</span></span><span>
</span><span class="comment1"><span>(*        [P, x1, ..., xn] |- a ==&gt; False ,                                  *)</span></span><span>
</span><span class="comment1"><span>(*      the second clause to                                                 *)</span></span><span>
</span><span class="comment1"><span>(*        [Q, y1, ..., ym] |- a' ==&gt; False                                   *)</span></span><span>
</span><span class="comment1"><span>(*      and then perform resolution with                                     *)</span></span><span>
</span><span class="comment1"><span>(*        [| ?P ==&gt; False; ~?P ==&gt; False |] ==&gt; False                        *)</span></span><span>
</span><span class="comment1"><span>(*      to produce                                                           *)</span></span><span>
</span><span class="comment1"><span>(*        [P, Q, x1, ..., xn, y1, ..., ym] |- False                          *)</span></span><span>
</span><span class="comment1"><span>(*      Each clause is accompanied with an association list mapping integers *)</span></span><span>
</span><span class="comment1"><span>(*      (positive for positive literals, negative for negative literals, and *)</span></span><span>
</span><span class="comment1"><span>(*      the same absolute value for dual literals) to the actual literals as *)</span></span><span>
</span><span class="comment1"><span>(*      cterms.                                                              *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>resolve_raw_clauses</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"Proof reconstruction failed (empty list of resolvents)!"</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>resolve_raw_clauses</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>c</span></span><span>::</span><span class="entity"><span>cs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
        </span><span class="comment1"><span>(* merges two sorted lists wrt. 'lit_ord', suppressing duplicates *)</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="entity"><span>xs</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>xs</span></span><span>
          </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>ys</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>ys</span></span><span>
          </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>xs</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>y</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>ys</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>lit_ord</span></span><span> </span><span class="main"><span>(</span></span><span>apply2</span><span> </span><span>fst</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>y</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
                </span><span>LESS</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="entity"><span>xs</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>y</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>ys</span></span><span class="main"><span>)</span></span><span>
              </span><span class="main"><span>|</span></span><span> </span><span>EQUAL</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="entity"><span>xs</span></span><span> </span><span class="entity"><span>ys</span></span><span>
              </span><span class="main"><span>|</span></span><span> </span><span>GREATER</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>y</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>xs</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ys</span></span><span class="main"><span>)</span></span><span>

        </span><span class="comment1"><span>(* find out which two hyps are used in the resolution *)</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>find_res_hyps</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"Proof reconstruction failed (no literal for resolution)!"</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
          </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>find_res_hyps</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"Proof reconstruction failed (no literal for resolution)!"</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
          </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>find_res_hyps</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h1</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>hyps1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>h2</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>hyps2</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>acc</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>lit_ord</span></span><span>  </span><span class="main"><span>(</span></span><span>apply2</span><span> </span><span>fst</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>h2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
                </span><span>LESS</span><span>  </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>find_res_hyps</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>hyps1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>h2</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>hyps2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h1</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>acc</span></span><span class="main"><span>)</span></span><span>
              </span><span class="main"><span>|</span></span><span> </span><span>EQUAL</span><span> </span><span class="main"><span>=&gt;</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
                    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>chyp1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>h1</span></span><span>
                    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i2</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>chyp2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>h2</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
                    </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>i1</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>~</span><span> </span><span class="entity"><span>i2</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span>
                      </span><span class="main"><span>(</span></span><span class="entity"><span>i1</span></span><span> </span><span>&lt;</span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>chyp1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>chyp2</span></span><span class="main"><span>,</span></span><span> </span><span>rev</span><span> </span><span class="entity"><span>acc</span></span><span> </span><span>@</span><span> </span><span class="entity"><span>merge</span></span><span> </span><span class="entity"><span>hyps1</span></span><span> </span><span class="entity"><span>hyps2</span></span><span class="main"><span>)</span></span><span>
                    </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="comment1"><span>(* i1 = i2 *)</span></span><span>
                      </span><span class="entity"><span>find_res_hyps</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>hyps1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyps2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h1</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>acc</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
          </span><span class="main"><span>|</span></span><span> </span><span>GREATER</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>find_res_hyps</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h1</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>hyps1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyps2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>h2</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>acc</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>

        </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>resolution</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>c1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyps1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>c2</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyps2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span class="inner_quoted"><span>"Resolving clause: "</span></span><span> </span><span>^</span><span> </span><span>Thm.string_of_thm</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>c1</span></span><span> </span><span>^</span><span>
                </span><span class="inner_quoted"><span>" (hyps: "</span></span><span> </span><span>^</span><span> </span><span>ML_Syntax.print_list</span><span> </span><span class="main"><span>(</span></span><span>Syntax.string_of_term</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.hyps_of</span><span> </span><span class="entity"><span>c1</span></span><span class="main"><span>)</span></span><span> </span><span>^</span><span>
                </span><span class="inner_quoted"><span>")\nwith clause: "</span></span><span> </span><span>^</span><span> </span><span>Thm.string_of_thm</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>c2</span></span><span> </span><span>^</span><span>
                </span><span class="inner_quoted"><span>" (hyps: "</span></span><span> </span><span>^</span><span> </span><span>ML_Syntax.print_list</span><span> </span><span class="main"><span>(</span></span><span>Syntax.string_of_term</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.hyps_of</span><span> </span><span class="entity"><span>c2</span></span><span class="main"><span>)</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>")"</span></span><span class="main"><span>)</span></span><span>

            </span><span class="comment1"><span>(* the two literals used for resolution *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>hyp1_is_neg</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyp1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyp2</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>new_hyps</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>find_res_hyps</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>hyps1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyps2</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>

            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>c1'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.implies_intr</span><span> </span><span class="entity"><span>hyp1</span></span><span> </span><span class="entity"><span>c1</span></span><span>  </span><span class="comment1"><span>(* Gamma1 |- hyp1 ==&gt; False *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>c2'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.implies_intr</span><span> </span><span class="entity"><span>hyp2</span></span><span> </span><span class="entity"><span>c2</span></span><span>  </span><span class="comment1"><span>(* Gamma2 |- hyp2 ==&gt; False *)</span></span><span>

            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>res_thm</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
                </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>P</span></span><span> </span><span class="main"><span>=</span></span><span>
                  </span><span>snd</span><span> </span><span class="main"><span>(</span></span><span>Thm.dest_comb</span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>hyp1_is_neg</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>hyp2</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>hyp1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>  </span><span class="comment1"><span>(* strip Trueprop *)</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
                </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">instantiate</span><span class="hidden">&gt;</span></span></span><span>‹</span><span class="free"><span class="entity"><span>P</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
                  </span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../HOL.html#HOL.False|const"><span>False</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><a class="entity_ref" href="../../../../HOL.html#HOL.Not|const"><span>¬</span></a></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../HOL.html#HOL.False|const"><span>False</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../HOL.html#HOL.False|const"><span>False</span></a><span>›</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../Provers/classical.ML.html#HOL.rule|method"><span class="operator"><span>rule</span></span></a><span> </span><a class="entity_ref" href="../../../../HOL.html#HOL.case_split|fact"><span>case_split</span></a><span class="main"><span>)</span></span><span>›</span></span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
                </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"Resolution theorem: "</span></span><span> </span><span>^</span><span> </span><span>Thm.string_of_thm</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>res_thm</span></span><span class="main"><span>)</span></span><span>

            </span><span class="comment1"><span>(* Gamma1, Gamma2 |- False *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>c_new</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span>Thm.implies_elim</span><span>
                </span><span class="main"><span>(</span></span><span>Thm.implies_elim</span><span> </span><span class="entity"><span>res_thm</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>hyp1_is_neg</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>c2'</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>c1'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>hyp1_is_neg</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>c1'</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>c2'</span></span><span class="main"><span>)</span></span><span>

            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span class="inner_quoted"><span>"Resulting clause: "</span></span><span> </span><span>^</span><span> </span><span>Thm.string_of_thm</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>c_new</span></span><span> </span><span>^</span><span>
                </span><span class="inner_quoted"><span>" (hyps: "</span></span><span> </span><span>^</span><span>
                </span><span>ML_Syntax.print_list</span><span> </span><span class="main"><span>(</span></span><span>Syntax.string_of_term</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.hyps_of</span><span> </span><span class="entity"><span>c_new</span></span><span class="main"><span>)</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>")"</span></span><span class="main"><span>)</span></span><span>

            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Unsynchronized.inc</span><span> </span><span class="entity"><span>counter</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
            </span><span class="main"><span>(</span></span><span class="entity"><span>c_new</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>new_hyps</span></span><span class="main"><span>)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
          </span><span>fold</span><span> </span><span class="entity"><span>resolution</span></span><span> </span><span class="entity"><span>cs</span></span><span> </span><span class="entity"><span>c</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* replay_proof: replays the resolution proof returned by the SAT solver;    *)</span></span><span>
</span><span class="comment1"><span>(*      cf. SAT_Solver.proof for details of the proof format.  Updates the   *)</span></span><span>
</span><span class="comment1"><span>(*      'clauses' array with derived clauses, and returns the derived clause *)</span></span><span>
</span><span class="comment1"><span>(*      at index 'empty_id' (which should just be "False" if proof           *)</span></span><span>
</span><span class="comment1"><span>(*      reconstruction was successful, with the used clauses as hyps).       *)</span></span><span>
</span><span class="comment1"><span>(*      'atom_table' must contain an injective mapping from all atoms that   *)</span></span><span>
</span><span class="comment1"><span>(*      occur (as part of a literal) in 'clauses' to positive integers.      *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>replay_proof</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>atom_table</span></span><span> </span><span class="entity"><span>clauses</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>clause_table</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>empty_id</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>index_of_literal</span></span><span> </span><span class="entity"><span>chyp</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>HOLogic.dest_Trueprop</span></span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>chyp</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
        </span><span class="main"><span>(</span></span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../HOL.html#HOL.Not|const"><span>Not</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>atom</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span>~</span><span> </span><span class="main"><span>(</span></span><span>the</span><span> </span><span class="main"><span>(</span></span><span>Termtab.lookup</span><span> </span><span class="entity"><span>atom_table</span></span><span> </span><span class="entity"><span>atom</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>atom</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span>the</span><span> </span><span class="main"><span>(</span></span><span>Termtab.lookup</span><span> </span><span class="entity"><span>atom_table</span></span><span> </span><span class="entity"><span>atom</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>TERM</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>;</span></span><span>  </span><span class="comment1"><span>(* 'chyp' is not a literal *)</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>prove_clause</span></span><span> </span><span class="entity"><span>id</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Array.nth</span><span> </span><span class="entity"><span>clauses</span></span><span> </span><span class="entity"><span>id</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
        </span><span class="entity"><span>RAW_CLAUSE</span></span><span> </span><span class="entity"><span>clause</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>clause</span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>ORIG_CLAUSE</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="comment1"><span>(* convert the original clause *)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"Using original clause #"</span></span><span> </span><span>^</span><span> </span><span>string_of_int</span><span> </span><span class="entity"><span>id</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>raw</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>CNF.clause2raw_thm</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>thm</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>hyps</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>sort</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>lit_ord</span></span><span> </span><span>o</span><span> </span><span>apply2</span><span> </span><span>fst</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>map_filter</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>chyp</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
              </span><span>Option.map</span><span> </span><span class="main"><span>(</span></span><span>rpair</span><span> </span><span class="entity"><span>chyp</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>index_of_literal</span></span><span> </span><span class="entity"><span>chyp</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.chyps_of</span><span> </span><span class="entity"><span>raw</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>clause</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>raw</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>hyps</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Array.upd</span><span> </span><span class="entity"><span>clauses</span></span><span> </span><span class="entity"><span>id</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>RAW_CLAUSE</span></span><span> </span><span class="entity"><span>clause</span></span><span class="main"><span>)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
            </span><span class="entity"><span>clause</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
      </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>NO_CLAUSE</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="comment1"><span>(* prove the clause, using information from 'clause_table' *)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"Proving clause #"</span></span><span> </span><span>^</span><span> </span><span>string_of_int</span><span> </span><span class="entity"><span>id</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>" ..."</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ids</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>the</span><span> </span><span class="main"><span>(</span></span><span>Inttab.lookup</span><span> </span><span class="entity"><span>clause_table</span></span><span> </span><span class="entity"><span>id</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>clause</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>resolve_raw_clauses</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="entity"><span>prove_clause</span></span><span> </span><span class="entity"><span>ids</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Array.upd</span><span> </span><span class="entity"><span>clauses</span></span><span> </span><span class="entity"><span>id</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>RAW_CLAUSE</span></span><span> </span><span class="entity"><span>clause</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
                </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"Replay chain successful; clause stored at #"</span></span><span> </span><span>^</span><span> </span><span>string_of_int</span><span> </span><span class="entity"><span>id</span></span><span class="main"><span>)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
            </span><span class="entity"><span>clause</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>

    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>counter</span></span><span> </span><span>:=</span><span> </span><span class="inner_numeral"><span>0</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>empty_clause</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>fst</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>prove_clause</span></span><span> </span><span class="entity"><span>empty_id</span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="inner_quoted"><span>"Proof reconstruction successful; "</span></span><span> </span><span>^</span><span>
        </span><span>string_of_int</span><span> </span><span class="main"><span>(</span></span><span>!</span><span class="entity"><span>counter</span></span><span class="main"><span>)</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>" resolution step(s) total."</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="entity"><span>empty_clause</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* string_of_prop_formula: return a human-readable string representation of  *)</span></span><span>
</span><span class="comment1"><span>(*      a 'prop_formula' (just for tracing)                                  *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>Prop_Logic.True</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"True"</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>Prop_Logic.False</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"False"</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Prop_Logic.BoolVar</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"x"</span></span><span> </span><span>^</span><span> </span><span>string_of_int</span><span> </span><span class="entity"><span>i</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Prop_Logic.Not</span></span><span> </span><span class="entity"><span>fm</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_quoted"><span>"~"</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>fm</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Prop_Logic.Or</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fm1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>fm2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="inner_quoted"><span>"("</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>fm1</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>" v "</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>fm2</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>")"</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Prop_Logic.And</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fm1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>fm2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="inner_quoted"><span>"("</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>fm1</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>" &amp; "</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>fm2</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>")"</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* rawsat_thm: run external SAT solver with the given clauses.  Reconstructs *)</span></span><span>
</span><span class="comment1"><span>(*      a proof from the resulting proof trace of the SAT solver.  The       *)</span></span><span>
</span><span class="comment1"><span>(*      theorem returned is just "False" (with some of the given clauses as  *)</span></span><span>
</span><span class="comment1"><span>(*      hyps).                                                               *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>rawsat_thm</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>clauses</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="comment1"><span>(* remove premises that equal "True" *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>clauses'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>filter</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>clause</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="main"><span>(</span></span><span>not_equal</span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../../../HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span></span><span> </span><span>o</span><span> </span><span class="entity"><span>HOLogic.dest_Trueprop</span></span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>clause</span></span><span>
        </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>TERM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"dest_Trueprop"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>true</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>clauses</span></span><span>
    </span><span class="comment1"><span>(* remove non-clausal premises -- of course this shouldn't actually   *)</span></span><span>
    </span><span class="comment1"><span>(* remove anything as long as 'rawsat_tac' is only called after the   *)</span></span><span>
    </span><span class="comment1"><span>(* premises have been converted to clauses                            *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>clauses''</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>filter</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>clause</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>CNF.is_clause</span></span><span> </span><span>o</span><span> </span><span class="entity"><span>HOLogic.dest_Trueprop</span></span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>clause</span></span><span>
        </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>TERM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"dest_Trueprop"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>false</span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>orelse</span></span></span><span>
       </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Context_Position.is_visible</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span>
          </span><span>warning</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"Ignoring non-clausal premise "</span></span><span> </span><span>^</span><span> </span><span>Syntax.string_of_term</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.term_of</span><span> </span><span class="entity"><span>clause</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span> </span><span>false</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>clauses'</span></span><span>
    </span><span class="comment1"><span>(* remove trivial clauses -- this is necessary because zChaff removes *)</span></span><span>
    </span><span class="comment1"><span>(* trivial clauses during preprocessing, and otherwise our clause     *)</span></span><span>
    </span><span class="comment1"><span>(* numbering would be off                                             *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>nontrivial_clauses</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>filter</span><span> </span><span class="main"><span>(</span></span><span>not</span><span> </span><span>o</span><span> </span><span class="entity"><span>CNF.clause_is_trivial</span></span><span> </span><span>o</span><span> </span><span class="entity"><span>HOLogic.dest_Trueprop</span></span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>clauses''</span></span><span>
    </span><span class="comment1"><span>(* sort clauses according to the term order -- an optimization,       *)</span></span><span>
    </span><span class="comment1"><span>(* useful because forming the union of hypotheses, as done by         *)</span></span><span>
    </span><span class="comment1"><span>(* Conjunction.intr_balanced and fold Thm.weaken below, is quadratic for *)</span></span><span>
    </span><span class="comment1"><span>(* terms sorted in descending order, while only linear for terms      *)</span></span><span>
    </span><span class="comment1"><span>(* sorted in ascending order                                          *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sorted_clauses</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>sort</span><span> </span><span>Thm.fast_term_ord</span><span> </span><span class="entity"><span>nontrivial_clauses</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="inner_quoted"><span>"Sorted non-trivial clauses:\n"</span></span><span> </span><span>^</span><span>
        </span><span>cat_lines</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span>Syntax.string_of_term</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>sorted_clauses</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
    </span><span class="comment1"><span>(* translate clauses from HOL terms to Prop_Logic.prop_formula *)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>fms</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>atom_table</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span>fold_map</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Prop_Logic.prop_formula_of_term</span></span><span> </span><span>o</span><span> </span><span class="entity"><span>HOLogic.dest_Trueprop</span></span><span> </span><span>o</span><span> </span><span>Thm.term_of</span><span class="main"><span>)</span></span><span>
        </span><span class="entity"><span>sorted_clauses</span></span><span> </span><span>Termtab.empty</span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
        </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"Invoking SAT solver on clauses:\n"</span></span><span> </span><span>^</span><span> </span><span>cat_lines</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="entity"><span>string_of_prop_formula</span></span><span> </span><span class="entity"><span>fms</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>fm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Prop_Logic.all</span></span><span> </span><span class="entity"><span>fms</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>make_quick_and_dirty_thm</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
          </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
            </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"quick_and_dirty is set: proof reconstruction skipped, using oracle instead"</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>False_thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Skip_Proof.make_thm_cterm</span><span> </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">cprop</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../../../HOL.html#HOL.False|const"><span>False</span></a><span>›</span></span></span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="comment1"><span>(* 'fold Thm.weaken (rev sorted_clauses)' is linear, while 'fold    *)</span></span><span>
        </span><span class="comment1"><span>(* Thm.weaken sorted_clauses' would be quadratic, since we sorted   *)</span></span><span>
        </span><span class="comment1"><span>(* clauses in ascending order (which is linear for                  *)</span></span><span>
        </span><span class="comment1"><span>(* 'Conjunction.intr_balanced', used below)                         *)</span></span><span>
        </span><span>fold</span><span> </span><span>Thm.weaken</span><span> </span><span class="main"><span>(</span></span><span>rev</span><span> </span><span class="entity"><span>sorted_clauses</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>False_thm</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>the_solver</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Config.get</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>solver</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"Invoking solver "</span></span><span> </span><span>^</span><span> </span><span class="entity"><span>the_solver</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>SAT_Solver.invoke_solver</span></span><span> </span><span class="entity"><span>the_solver</span></span><span> </span><span class="entity"><span>fm</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
      </span><span class="entity"><span>SAT_Solver.UNSATISFIABLE</span></span><span> </span><span class="main"><span>(</span></span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>clause_table</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>empty_id</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
       </span><span class="main"><span>(</span></span><span class="entity"><span>cond_tracing</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="inner_quoted"><span>"Proof trace from SAT solver:\n"</span></span><span> </span><span>^</span><span>
          </span><span class="inner_quoted"><span>"clauses: "</span></span><span> </span><span>^</span><span> </span><span>ML_Syntax.print_list</span><span>
            </span><span class="main"><span>(</span></span><span>ML_Syntax.print_pair</span><span> </span><span>ML_Syntax.print_int</span><span> </span><span class="main"><span>(</span></span><span>ML_Syntax.print_list</span><span> </span><span>ML_Syntax.print_int</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="main"><span>(</span></span><span>Inttab.dest</span><span> </span><span class="entity"><span>clause_table</span></span><span class="main"><span>)</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>"\n"</span></span><span> </span><span>^</span><span>
          </span><span class="inner_quoted"><span>"empty clause: "</span></span><span> </span><span>^</span><span> </span><span>string_of_int</span><span> </span><span class="entity"><span>empty_id</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Config.get</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>quick_and_dirty</span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span>
          </span><span class="entity"><span>make_quick_and_dirty_thm</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
            </span><span class="comment1"><span>(* optimization: convert the given clauses to "[c_1 &amp;&amp; ... &amp;&amp; c_n] |- c_i";  *)</span></span><span>
            </span><span class="comment1"><span>(*               this avoids accumulation of hypotheses during resolution    *)</span></span><span>
            </span><span class="comment1"><span>(* [c_1, ..., c_n] |- c_1 &amp;&amp; ... &amp;&amp; c_n *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>clauses_thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Conjunction.intr_balanced</span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span>Thm.assume</span><span> </span><span class="entity"><span>sorted_clauses</span></span><span class="main"><span>)</span></span><span>
            </span><span class="comment1"><span>(* [c_1 &amp;&amp; ... &amp;&amp; c_n] |- c_1 &amp;&amp; ... &amp;&amp; c_n *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>clauses_cprop</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.cprop_of</span><span> </span><span class="entity"><span>clauses_thm</span></span><span>
            </span><span class="comment1"><span>(* [[c_1 &amp;&amp; ... &amp;&amp; c_n] |- c_1, ..., [c_1 &amp;&amp; ... &amp;&amp; c_n] |- c_n] *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>cnf_clauses</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span>Conjunction.elim_balanced</span><span> </span><span class="main"><span>(</span></span><span>length</span><span> </span><span class="entity"><span>sorted_clauses</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.assume</span><span> </span><span class="entity"><span>clauses_cprop</span></span><span class="main"><span>)</span></span><span>
            </span><span class="comment1"><span>(* initialize the clause array with the given clauses *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>max_idx</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>fst</span><span> </span><span class="main"><span>(</span></span><span>the</span><span> </span><span class="main"><span>(</span></span><span>Inttab.max</span><span> </span><span class="entity"><span>clause_table</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>clause_arr</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Array.array</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>max_idx</span></span><span> </span><span>+</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>NO_CLAUSE</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span>
              </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span>Array.upd</span><span> </span><span class="entity"><span>clause_arr</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ORIG_CLAUSE</span></span><span> </span><span class="entity"><span>thm</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span>+</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                </span><span class="entity"><span>cnf_clauses</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span>
            </span><span class="comment1"><span>(* replay the proof to derive the empty clause *)</span></span><span>
            </span><span class="comment1"><span>(* [c_1 &amp;&amp; ... &amp;&amp; c_n] |- False *)</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>raw_thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>replay_proof</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>atom_table</span></span><span> </span><span class="entity"><span>clause_arr</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>clause_table</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>empty_id</span></span><span class="main"><span>)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
            </span><span class="comment1"><span>(* [c_1, ..., c_n] |- False *)</span></span><span>
            </span><span>Thm.implies_elim</span><span> </span><span class="main"><span>(</span></span><span>Thm.implies_intr</span><span> </span><span class="entity"><span>clauses_cprop</span></span><span> </span><span class="entity"><span>raw_thm</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>clauses_thm</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>SAT_Solver.UNSATISFIABLE</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Config.get</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>quick_and_dirty</span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span>
         </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Context_Position.is_visible</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span>
            </span><span>warning</span><span> </span><span class="inner_quoted"><span>"SAT solver claims the formula to be unsatisfiable, but did not provide a proof"</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
          </span><span class="entity"><span>make_quick_and_dirty_thm</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span>
          </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"SAT solver claims the formula to be unsatisfiable, but did not provide a proof"</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>SAT_Solver.SATISFIABLE</span></span><span> </span><span class="entity"><span>assignment</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>msg</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span class="inner_quoted"><span>"SAT solver found a countermodel:\n"</span></span><span> </span><span>^</span><span>
            </span><span class="main"><span>(</span></span><span>commas</span><span> </span><span>o</span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>term</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>idx</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span>Syntax.string_of_term_global</span><span> </span><span class="antiquoted"><span class="operator"><span class="entity"><span><span class="hidden">\&lt;^</span><span class="control">theory</span><span class="hidden">&gt;</span></span></span></span></span><span> </span><span class="entity"><span>term</span></span><span> </span><span>^</span><span> </span><span class="inner_quoted"><span>": "</span></span><span> </span><span>^</span><span>
                  </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>assignment</span></span><span> </span><span class="entity"><span>idx</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"arbitrary"</span></span><span>
                  </span><span class="main"><span>|</span></span><span> </span><span>SOME</span><span> </span><span>true</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"true"</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span>SOME</span><span> </span><span>false</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="inner_quoted"><span>"false"</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
              </span><span class="main"><span>(</span></span><span>Termtab.dest</span><span> </span><span class="entity"><span>atom_table</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
          </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>msg</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>SAT_Solver.UNKNOWN</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"SAT solver failed to decide the formula"</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* Tactics                                                                   *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* rawsat_tac: solves the i-th subgoal of the proof state; this subgoal      *)</span></span><span>
</span><span class="comment1"><span>(*      should be of the form                                                *)</span></span><span>
</span><span class="comment1"><span>(*        [| c1; c2; ...; ck |] ==&gt; False                                    *)</span></span><span>
</span><span class="comment1"><span>(*      where each cj is a non-empty clause (i.e. a disjunction of literals) *)</span></span><span>
</span><span class="comment1"><span>(*      or "True"                                                            *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>rawsat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>Subgoal.FOCUS</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>{</span></span><span>context </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>prems</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>...</span></span><span class="main"><span>}</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
    </span><span>resolve_tac</span><span> </span><span class="entity"><span>ctxt'</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>rawsat_thm</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span> </span><span class="main"><span>(</span></span><span>map</span><span> </span><span>Thm.cprop_of</span><span> </span><span class="entity"><span>prems</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* pre_cnf_tac: converts the i-th subgoal                                    *)</span></span><span>
</span><span class="comment1"><span>(*        [| A1 ; ... ; An |] ==&gt; B                                          *)</span></span><span>
</span><span class="comment1"><span>(*      to                                                                   *)</span></span><span>
</span><span class="comment1"><span>(*        [| A1; ... ; An ; ~B |] ==&gt; False                                  *)</span></span><span>
</span><span class="comment1"><span>(*      (handling meta-logical connectives in B properly before negating),   *)</span></span><span>
</span><span class="comment1"><span>(*      then replaces meta-logical connectives in the premises (i.e. "==&gt;",  *)</span></span><span>
</span><span class="comment1"><span>(*      "!!" and "==") by connectives of the HOL object-logic (i.e. by       *)</span></span><span>
</span><span class="comment1"><span>(*      "--&gt;", "!", and "="), then performs beta-eta-normalization on the    *)</span></span><span>
</span><span class="comment1"><span>(*      subgoal                                                              *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>pre_cnf_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>resolve_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thms</span></span><span> </span><a class="entity_ref" href="../../../../HOL.html#HOL.ccontr|fact"><span>ccontr</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>THEN'</span><span>
  </span><span>Object_Logic.atomize_prems_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>THEN'</span><span>
  </span><span>CONVERSION</span><span> </span><span>Drule.beta_eta_conversion</span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* cnfsat_tac: checks if the empty clause "False" occurs among the premises; *)</span></span><span>
</span><span class="comment1"><span>(*      if not, eliminates conjunctions (i.e. each clause of the CNF formula *)</span></span><span>
</span><span class="comment1"><span>(*      becomes a separate premise), then applies 'rawsat_tac' to solve the  *)</span></span><span>
</span><span class="comment1"><span>(*      subgoal                                                              *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>cnfsat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="main"><span>(</span></span><span>eresolve_tac</span><span>  </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>FalseE</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span> </span><span>ORELSE</span><span>
  </span><span class="main"><span>(</span></span><span>REPEAT_DETERM</span><span> </span><span class="main"><span>(</span></span><span>eresolve_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>conjE</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span> </span><span>THEN</span><span> </span><span class="entity"><span>rawsat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* cnfxsat_tac: checks if the empty clause "False" occurs among the          *)</span></span><span>
</span><span class="comment1"><span>(*      premises; if not, eliminates conjunctions (i.e. each clause of the   *)</span></span><span>
</span><span class="comment1"><span>(*      CNF formula becomes a separate premise) and existential quantifiers, *)</span></span><span>
</span><span class="comment1"><span>(*      then applies 'rawsat_tac' to solve the subgoal                       *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>cnfxsat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="main"><span>(</span></span><span>eresolve_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>FalseE</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span> </span><span>ORELSE</span><span>
    </span><span class="main"><span>(</span></span><span>REPEAT_DETERM</span><span> </span><span class="main"><span>(</span></span><span>eresolve_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>conjE</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span>ORELSE</span><span> </span><span>eresolve_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>exE</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span> </span><span>THEN</span><span>
      </span><span class="entity"><span>rawsat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* sat_tac: tactic for calling an external SAT solver, taking as input an    *)</span></span><span>
</span><span class="comment1"><span>(*      arbitrary formula.  The input is translated to CNF, possibly causing *)</span></span><span>
</span><span class="comment1"><span>(*      an exponential blowup.                                               *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>sat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>pre_cnf_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span>THEN</span><span> </span><span class="entity"><span>CNF.cnf_rewrite_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span>THEN</span><span> </span><span class="entity"><span>cnfsat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>;</span></span><span>

</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>
</span><span class="comment1"><span>(* satx_tac: tactic for calling an external SAT solver, taking as input an   *)</span></span><span>
</span><span class="comment1"><span>(*      arbitrary formula.  The input is translated to CNF, possibly         *)</span></span><span>
</span><span class="comment1"><span>(*      introducing new literals.                                            *)</span></span><span>
</span><span class="comment1"><span>(* ------------------------------------------------------------------------- *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>satx_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>pre_cnf_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span>THEN</span><span> </span><span class="entity"><span>CNF.cnfx_rewrite_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span>THEN</span><span> </span><span class="entity"><span>cnfxsat_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>
</span></pre>
</body>

</html>